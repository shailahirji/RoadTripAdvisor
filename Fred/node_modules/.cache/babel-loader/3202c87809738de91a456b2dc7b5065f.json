{"ast":null,"code":"import _classCallCheck from \"/Users/shaila/Documents/GitHub/RoadTripAdvisor/Shaila/RTA-landing-meal/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shaila/Documents/GitHub/RoadTripAdvisor/Shaila/RTA-landing-meal/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/shaila/Documents/GitHub/RoadTripAdvisor/Shaila/RTA-landing-meal/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/shaila/Documents/GitHub/RoadTripAdvisor/Shaila/RTA-landing-meal/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/shaila/Documents/GitHub/RoadTripAdvisor/Shaila/RTA-landing-meal/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _objectSpread from \"/Users/shaila/Documents/GitHub/RoadTripAdvisor/Shaila/RTA-landing-meal/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _regeneratorRuntime from \"/Users/shaila/Documents/GitHub/RoadTripAdvisor/Shaila/RTA-landing-meal/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/shaila/Documents/GitHub/RoadTripAdvisor/Shaila/RTA-landing-meal/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nvar _jsxFileName = \"/Users/shaila/Documents/GitHub/RoadTripAdvisor/Shaila/RTA-landing-meal/src/components/MealMap.js\";\n\n/*global google*/\nimport React from \"react\";\nimport { compose, withProps, withHandlers, withState, withStateHandlers, lifecycle } from \"recompose\";\nimport { withScriptjs, withGoogleMap, GoogleMap, Marker, InfoWindow, DirectionsRenderer } from \"react-google-maps\";\nimport { connect } from 'react-redux';\nimport meal from './meal.png';\nimport bakery from './bakery.png';\nvar route_markers = [];\nvar center;\nvar MyMapComponent = compose(withProps({\n  googleMapURL: \"https://maps.googleapis.com/maps/api/js?key=AIzaSyD8kEdQYnlfJaGYD70GNqtxzf7oet_3wwY&libraries=places,geometry\",\n  loadingElement: React.createElement(\"div\", {\n    style: {\n      height: '100vh'\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 16\n    },\n    __self: this\n  }),\n  containerElement: React.createElement(\"div\", {\n    style: {\n      height: '100vh'\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 17\n    },\n    __self: this\n  }),\n  mapElement: React.createElement(\"div\", {\n    style: {\n      position: \"relative\",\n      width: \"50%\",\n      height: 480,\n      //WebkitFilter: \"drop-shadow(0px 0px 30px )\",\n      marginLeft: 482,\n      marginTop: -510\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 18\n    },\n    __self: this\n  })\n}), withScriptjs, withGoogleMap, lifecycle({\n  componentWillMount: function componentWillMount() {\n    this.getGeoLocation();\n  },\n  getGeoLocation: function () {\n    var _getGeoLocation = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var locations, from, to;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.props.locations) {\n                _context.next = 13;\n                break;\n              }\n\n              locations = this.props.locations; //passing array with start and end destination names \n\n              route_markers = []; //used to store the geolocation \n\n              _context.next = 5;\n              return this.getLocationCoordinates(locations.from);\n\n            case 5:\n              from = _context.sent;\n              _context.next = 8;\n              return this.getLocationCoordinates(locations.to);\n\n            case 8:\n              to = _context.sent;\n              //returns coordinates of end dest\n              route_markers.push(from); //add to the array\n\n              route_markers.push(to); //add to the array \n\n              this.setState({\n                markers: route_markers\n              });\n              this.componentDidMount(route_markers);\n\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function getGeoLocation() {\n      return _getGeoLocation.apply(this, arguments);\n    }\n\n    return getGeoLocation;\n  }(),\n  getLocationCoordinates: function getLocationCoordinates(location) {\n    //computes the geocoordinates of given locations using googles Geocoder \n    return new Promise(function (resolve, reject) {\n      var geocoder = new window.google.maps.Geocoder();\n      geocoder.geocode({\n        address: location\n      }, function (result, status) {\n        if (status == 'OK') {\n          var geometry = result[0].geometry.location;\n          var coordinates = {\n            lat: geometry.lat(),\n            lng: geometry.lng()\n          };\n          resolve(coordinates);\n        } else {\n          reject('ERROR');\n        }\n      });\n    });\n  },\n  componentDidMount: function componentDidMount(route_markers) {\n    var _this = this;\n\n    //this method draws the route between start and end destination\n    if (route_markers) {\n      var DirectionsService = new google.maps.DirectionsService();\n      DirectionsService.route({\n        origin: new google.maps.LatLng(route_markers[0].lat, route_markers[0].lng),\n        destination: new google.maps.LatLng(route_markers[1].lat, route_markers[1].lng),\n        travelMode: google.maps.TravelMode.DRIVING\n      }, function (result, status) {\n        if (status === google.maps.DirectionsStatus.OK) {\n          //console.log(result)\n          _this.setState({\n            directions: _objectSpread({}, result),\n            markers: true\n          });\n        } else {\n          console.error(\"error fetching directions \".concat(result));\n        }\n      });\n    }\n  }\n}), withState('places', 'updatePlaces', '', 'searchCriteria', 'radius', 'currLat', 'currLng'), withStateHandlers(function () {\n  return {\n    isOpen: false,\n    markerIndex: 0,\n    currentLatLng: {\n      lat: 47.6769683,\n      lng: -90.6769683\n    }\n  };\n}, {\n  onToggleOpen: function onToggleOpen(_ref) {\n    var isOpen = _ref.isOpen;\n    return function (index) {\n      return {\n        //used to handle info window on markers \n        isOpen: !isOpen,\n        markerIndex: index\n      };\n    };\n  }\n}), withHandlers(function () {\n  var refs = {\n    map: undefined,\n    array: []\n  };\n  return {\n    onMapMounted: function onMapMounted() {\n      return function (ref) {\n        refs.map = ref;\n      };\n    },\n    fetchPlaces: function () {\n      var _fetchPlaces = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(_ref2) {\n        var updatePlaces, searchCriteria, radius, price, review, defaultCenter, bounds, maxPrice, service, x, output, request;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                updatePlaces = _ref2.updatePlaces, searchCriteria = _ref2.searchCriteria, radius = _ref2.radius, price = _ref2.price, review = _ref2.review, defaultCenter = _ref2.defaultCenter;\n                //fetches new places to dispaly on map by making a request to googles PlaceService api\n                bounds = refs.map.getBounds();\n                center = refs.map.getCenter();\n                refs.map.panToBounds(bounds);\n                console.log(bounds);\n                refs.array = searchCriteria;\n                maxPrice = price;\n                service = new google.maps.places.PlacesService(refs.map.context.__SECRET_MAP_DO_NOT_USE_OR_YOU_WILL_BE_FIRED);\n                output = [];\n                x = 0;\n\n              case 10:\n                if (!(x < refs.array.length)) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                request = {\n                  location: defaultCenter,\n                  //location:(new google.maps.LatLng(47.6769683,-122.0284808)),or {lat:47.6769683,lng:-122.0284808}\n                  bounds: bounds,\n                  radius: radius,\n                  type: refs.array[x],\n                  openNow: true,\n                  maxPriceLevel: maxPrice,\n                  fields: ['photos', 'formatted_address', 'name', 'rating', 'opening_hours', 'geometry']\n                };\n                _context2.next = 14;\n                return service.nearbySearch(request, function (results, status) {\n                  return new Promise(function (reject, resolve) {\n                    if (status === google.maps.places.PlacesServiceStatus.OK) {\n                      var x;\n\n                      for (x = 0; x < results.length; x++) {\n                        output.push(results[x]);\n                      }\n\n                      resolve(output);\n                      updatePlaces(output);\n                    } else {\n                      reject();\n                    }\n                  });\n                });\n\n              case 14:\n                x++;\n                _context2.next = 10;\n                break;\n\n              case 17:\n                //end of forloop \n                console.log(output);\n\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fetchPlaces(_x) {\n        return _fetchPlaces.apply(this, arguments);\n      }\n\n      return fetchPlaces;\n    }(),\n    currentLoc: function currentLoc(_ref3) {\n      var currLat = _ref3.currLat,\n          currLng = _ref3.currLng;\n\n      if (navigator.geolocation) {\n        navigator.geolocation.getCurrentPosition(function (position) {\n          currLat = position.coords.latitude;\n          currLng = position.coords.longitude;\n        });\n      }\n    }\n  };\n}))(function (props) {\n  console.log(route_markers);\n  if (props.places != null) if (route_markers[0] !== undefined) var target = new google.maps.LatLng(47.6062, -122.3321); //this needs to update with the bound and not be fixed like this\n\n  console.log(\"TARGET:\" + target);\n\n  if (props.defaultCenter !== undefined) {\n    target = props.defaultCenter;\n  }\n\n  console.log(center);\n  var option = []; //new array to store results based on search criteria\n\n  if (props.places) {\n    //traverse through the place array, if there is a match between radius , price level. Enables makers to show without other information \n    props.places.map(function (place, i) {\n      console.log(props.radius);\n      var x = google.maps.geometry.spherical.computeDistanceBetween(target, new google.maps.LatLng(place.geometry.location.lat(), place.geometry.location.lng()));\n      console.log(x);\n\n      if (google.maps.geometry.spherical.computeDistanceBetween(target, new google.maps.LatLng(place.geometry.location.lat(), place.geometry.location.lng())) < props.radius) {\n        console.log(\"DISTANCE MATCH\");\n        option.push(place);\n      }\n\n      if (place.price_level <= props.price) {\n        console.log(\"PRICE MATCH\");\n        option.push(place);\n      }\n\n      if (place.rating <= props.ratings) {\n        console.log(\"RATINGS MATCH\");\n        option.push(place);\n      }\n      /*\n      cant have any markers appear if user enters only type, we need more information along with type. \n      */\n      // if(place.types.length !== 0 && place.types.includes(props.searchCriteria)){ \n      //     console.log(\"here \"+props.searchCriteria)\n      //     option.push(place)\n      // }\n\n    });\n  }\n\n  console.log(option);\n  return React.createElement(GoogleMap, {\n    onTilesLoaded: props.fetchPlaces,\n    ref: props.onMapMounted,\n    onClick: props.fetchPlaces,\n    defaultZoom: 13,\n    defaultCenter: {\n      lat: 47.6769683,\n      lng: -122.0284808\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 221\n    },\n    __self: this\n  }, option && option.map(function (place, i) {\n    return React.createElement(Marker, {\n      key: i,\n      position: {\n        lat: place.geometry.location.lat(),\n        lng: place.geometry.location.lng()\n      },\n      onClick: function onClick() {\n        props.onToggleOpen(i);\n      },\n      icon: {\n        url: place.icon,\n        scaledSize: new google.maps.Size(25, 25)\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 231\n      },\n      __self: this\n    }, props.isOpen && props.markerIndex === i && React.createElement(InfoWindow, {\n      onCloseClick: props.onToggleOpen,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 234\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 235\n      },\n      __self: this\n    }, place.name)));\n  }), props.directions && React.createElement(DirectionsRenderer, {\n    directions: props.directions,\n    suppressMarkers: props.markers,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 243\n    },\n    __self: this\n  }));\n});\n\nvar MealMap =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(MealMap, _React$Component);\n\n  function MealMap() {\n    _classCallCheck(this, MealMap);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MealMap).apply(this, arguments));\n  }\n\n  _createClass(MealMap, [{\n    key: \"render\",\n    value: function render() {\n      var searchCriteria = this.props.search;\n      var radius = this.props.radius;\n      var price = this.props.price;\n      var ratings = this.props.reviews;\n      var types = [];\n      var locations = this.props.locations;\n\n      if (searchCriteria.length !== 0 || radius !== 0 || price !== 0) {\n        console.log(searchCriteria + \" \" + radius + \" \" + price + \" \" + ratings);\n        searchCriteria.map(function (select) {\n          types.push(select.label);\n        });\n        return React.createElement(MyMapComponent, {\n          searchCriteria: types,\n          price: price * 1,\n          review: ratings,\n          radius: radius * 1609 //converting into meters\n          ,\n          locations: locations,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 273\n          },\n          __self: this\n        });\n      }\n\n      return (//to prevent from crashing\n        React.createElement(MyMapComponent, {\n          searchCriteria: \"\",\n          price: \"any\",\n          review: \"any\",\n          radius: \"0\",\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 283\n          },\n          __self: this\n        })\n      );\n    }\n  }]);\n\n  return MealMap;\n}(React.Component);\n\nexport { MealMap as default };","map":{"version":3,"sources":["/Users/shaila/Documents/GitHub/RoadTripAdvisor/Shaila/RTA-landing-meal/src/components/MealMap.js"],"names":["React","compose","withProps","withHandlers","withState","withStateHandlers","lifecycle","withScriptjs","withGoogleMap","GoogleMap","Marker","InfoWindow","DirectionsRenderer","connect","meal","bakery","route_markers","center","MyMapComponent","googleMapURL","loadingElement","height","containerElement","mapElement","position","width","marginLeft","marginTop","componentWillMount","getGeoLocation","props","locations","getLocationCoordinates","from","to","push","setState","markers","componentDidMount","location","Promise","resolve","reject","geocoder","window","google","maps","Geocoder","geocode","address","result","status","geometry","coordinates","lat","lng","DirectionsService","route","origin","LatLng","destination","travelMode","TravelMode","DRIVING","DirectionsStatus","OK","directions","console","error","isOpen","markerIndex","currentLatLng","onToggleOpen","index","refs","map","undefined","array","onMapMounted","ref","fetchPlaces","updatePlaces","searchCriteria","radius","price","review","defaultCenter","bounds","getBounds","getCenter","panToBounds","log","maxPrice","service","places","PlacesService","context","__SECRET_MAP_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","output","x","length","request","type","openNow","maxPriceLevel","fields","nearbySearch","results","PlacesServiceStatus","currentLoc","currLat","currLng","navigator","geolocation","getCurrentPosition","coords","latitude","longitude","target","option","place","i","spherical","computeDistanceBetween","price_level","rating","ratings","url","icon","scaledSize","Size","name","MealMap","search","reviews","types","select","label","Component"],"mappings":";;;;;;;;;;AAAA;AACA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,OAAT,EAAkBC,SAAlB,EAA6BC,YAA7B,EAA2CC,SAA3C,EAAsDC,iBAAtD,EAAyEC,SAAzE,QAA0F,WAA1F;AACA,SAASC,YAAT,EAAuBC,aAAvB,EAAsCC,SAAtC,EAAiDC,MAAjD,EAAyDC,UAAzD,EAAqEC,kBAArE,QAA+F,mBAA/F;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,OAAOC,IAAP,MAAiB,YAAjB;AACA,OAAOC,MAAP,MAAmB,cAAnB;AAEA,IAAIC,aAAa,GAAG,EAApB;AACA,IAAIC,MAAJ;AACA,IAAMC,cAAc,GAAGjB,OAAO,CAE1BC,SAAS,CACL;AACIiB,EAAAA,YAAY,EAAE,+GADlB;AAEIC,EAAAA,cAAc,EAAE;AAAK,IAAA,KAAK,EAAE;AAAEC,MAAAA,MAAM,EAAE;AAAV,KAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAFpB;AAGIC,EAAAA,gBAAgB,EAAE;AAAK,IAAA,KAAK,EAAE;AAAED,MAAAA,MAAM,EAAE;AAAV,KAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAHtB;AAIIE,EAAAA,UAAU,EAAE;AAAK,IAAA,KAAK,EAAE;AACpBC,MAAAA,QAAQ,EAAE,UADU;AAEpBC,MAAAA,KAAK,EAAE,KAFa;AAGpBJ,MAAAA,MAAM,EAAE,GAHY;AAIpB;AACAK,MAAAA,UAAU,EAAE,GALQ;AAMpBC,MAAAA,SAAS,EAAE,CAAC;AANQ,KAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJhB,CADK,CAFiB,EAgB1BpB,YAhB0B,EAiB1BC,aAjB0B,EAkB1BF,SAAS,CAAC;AACNsB,EAAAA,kBADM,gCACc;AAChB,SAAKC,cAAL;AACH,GAHK;AAIAA,EAAAA,cAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAKC,KAAKC,KAAL,CAAWC,SALZ;AAAA;AAAA;AAAA;;AAMMA,cAAAA,SANN,GAMkB,KAAKD,KAAL,CAAWC,SAN7B,EAMwC;;AACvCf,cAAAA,aAAa,GAAG,EAAhB,CAPD,CAOoB;;AAPpB;AAAA,qBAQiB,KAAKgB,sBAAL,CAA4BD,SAAS,CAACE,IAAtC,CARjB;;AAAA;AAQIA,cAAAA,IARJ;AAAA;AAAA,qBASe,KAAKD,sBAAL,CAA4BD,SAAS,CAACG,EAAtC,CATf;;AAAA;AASIA,cAAAA,EATJ;AAS0D;AAC5DlB,cAAAA,aAAa,CAACmB,IAAd,CAAmBF,IAAnB,EAVE,CAUwB;;AAC1BjB,cAAAA,aAAa,CAACmB,IAAd,CAAmBD,EAAnB,EAXE,CAWqB;;AACvB,mBAAKE,QAAL,CAAc;AAACC,gBAAAA,OAAO,EAACrB;AAAT,eAAd;AACA,mBAAKsB,iBAAL,CAAuBtB,aAAvB;;AAbE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAiBJgB,EAAAA,sBAjBI,kCAiBmBO,QAjBnB,EAiB4B;AAAC;AAC/B,WAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAmB;AACpC,UAAMC,QAAQ,GAAG,IAAIC,MAAM,CAACC,MAAP,CAAcC,IAAd,CAAmBC,QAAvB,EAAjB;AACAJ,MAAAA,QAAQ,CAACK,OAAT,CAAiB;AAACC,QAAAA,OAAO,EAACV;AAAT,OAAjB,EAAqC,UAACW,MAAD,EAASC,MAAT,EAAkB;AACrD,YAAGA,MAAM,IAAE,IAAX,EAAgB;AACd,cAAMC,QAAQ,GAAGF,MAAM,CAAC,CAAD,CAAN,CAAUE,QAAV,CAAmBb,QAApC;AACA,cAAMc,WAAW,GAAG;AAClBC,YAAAA,GAAG,EAAEF,QAAQ,CAACE,GAAT,EADa;AAElBC,YAAAA,GAAG,EAACH,QAAQ,CAACG,GAAT;AAFc,WAApB;AAIAd,UAAAA,OAAO,CAACY,WAAD,CAAP;AAED,SARD,MASI;AACFX,UAAAA,MAAM,CAAC,OAAD,CAAN;AACD;AACF,OAbD;AAeD,KAjBM,CAAP;AAmBD,GArCG;AAsCNJ,EAAAA,iBAtCM,6BAsCYtB,aAtCZ,EAsC2B;AAAA;;AAAE;AAC/B,QAAGA,aAAH,EAAiB;AACjB,UAAMwC,iBAAiB,GAAG,IAAIX,MAAM,CAACC,IAAP,CAAYU,iBAAhB,EAA1B;AACAA,MAAAA,iBAAiB,CAACC,KAAlB,CAAwB;AACpBC,QAAAA,MAAM,EAAE,IAAIb,MAAM,CAACC,IAAP,CAAYa,MAAhB,CAAuB3C,aAAa,CAAC,CAAD,CAAb,CAAiBsC,GAAxC,EAA6CtC,aAAa,CAAC,CAAD,CAAb,CAAiBuC,GAA9D,CADY;AAEpBK,QAAAA,WAAW,EAAE,IAAIf,MAAM,CAACC,IAAP,CAAYa,MAAhB,CAAuB3C,aAAa,CAAC,CAAD,CAAb,CAAiBsC,GAAxC,EAA6CtC,aAAa,CAAC,CAAD,CAAb,CAAiBuC,GAA9D,CAFO;AAGpBM,QAAAA,UAAU,EAAEhB,MAAM,CAACC,IAAP,CAAYgB,UAAZ,CAAuBC;AAHf,OAAxB,EAIG,UAACb,MAAD,EAASC,MAAT,EAAoB;AACnB,YAAIA,MAAM,KAAKN,MAAM,CAACC,IAAP,CAAYkB,gBAAZ,CAA6BC,EAA5C,EAAgD;AAChE;AACoB,UAAA,KAAI,CAAC7B,QAAL,CAAc;AACV8B,YAAAA,UAAU,oBAAOhB,MAAP,CADA;AAEVb,YAAAA,OAAO,EAAE;AAFC,WAAd;AAIH,SAND,MAMO;AACH8B,UAAAA,OAAO,CAACC,KAAR,qCAA2ClB,MAA3C;AACH;AACJ,OAdD;AAeH;AACJ;AAzDS,CAAD,CAlBiB,EA6E1B9C,SAAS,CAAC,QAAD,EAAW,cAAX,EAA2B,EAA3B,EAA+B,gBAA/B,EAAiD,QAAjD,EAA2D,SAA3D,EAAsE,SAAtE,CA7EiB,EA8E1BC,iBAAiB,CAAC;AAAA,SAAO;AACrBgE,IAAAA,MAAM,EAAE,KADa;AAErBC,IAAAA,WAAW,EAAE,CAFQ;AAGrBC,IAAAA,aAAa,EAAE;AACXjB,MAAAA,GAAG,EAAE,UADM;AACMC,MAAAA,GAAG,EAAE,CAAC;AADZ;AAHM,GAAP;AAAA,CAAD,EAMb;AACIiB,EAAAA,YAAY,EAAE;AAAA,QAAGH,MAAH,QAAGA,MAAH;AAAA,WAAgB,UAACI,KAAD;AAAA,aAAY;AAAE;AACxCJ,QAAAA,MAAM,EAAE,CAACA,MAD6B;AAEtCC,QAAAA,WAAW,EAAEG;AAFyB,OAAZ;AAAA,KAAhB;AAAA;AADlB,CANa,CA9ES,EA2F1BtE,YAAY,CAAC,YAAM;AACf,MAAMuE,IAAI,GAAG;AACTC,IAAAA,GAAG,EAAEC,SADI;AAETC,IAAAA,KAAK,EAAE;AAFE,GAAb;AAIA,SAAO;AACHC,IAAAA,YAAY,EAAE;AAAA,aAAM,UAAAC,GAAG,EAAI;AACvBL,QAAAA,IAAI,CAACC,GAAL,GAAWI,GAAX;AACH,OAFa;AAAA,KADX;AAIHC,IAAAA,WAAW;AAAA;AAAA;AAAA,+BAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAASC,gBAAAA,YAAT,SAASA,YAAT,EAAuBC,cAAvB,SAAuBA,cAAvB,EAAuCC,MAAvC,SAAuCA,MAAvC,EAA+CC,KAA/C,SAA+CA,KAA/C,EAAsDC,MAAtD,SAAsDA,MAAtD,EAA8DC,aAA9D,SAA8DA,aAA9D;AAAoF;AACvFC,gBAAAA,MADG,GACMb,IAAI,CAACC,GAAL,CAASa,SAAT,EADN;AAETvE,gBAAAA,MAAM,GAACyD,IAAI,CAACC,GAAL,CAASc,SAAT,EAAP;AACAf,gBAAAA,IAAI,CAACC,GAAL,CAASe,WAAT,CAAqBH,MAArB;AACApB,gBAAAA,OAAO,CAACwB,GAAR,CAAYJ,MAAZ;AACAb,gBAAAA,IAAI,CAACG,KAAL,GAAaK,cAAb;AACIU,gBAAAA,QANK,GAMMR,KANN;AAOHS,gBAAAA,OAPG,GAOO,IAAIhD,MAAM,CAACC,IAAP,CAAYgD,MAAZ,CAAmBC,aAAvB,CAAqCrB,IAAI,CAACC,GAAL,CAASqB,OAAT,CAAiBC,4CAAtD,CAPP;AASLC,gBAAAA,MATK,GASI,EATJ;AAWJC,gBAAAA,CAAC,GAAG,CAXA;;AAAA;AAAA,sBAWGA,CAAC,GAAGzB,IAAI,CAACG,KAAL,CAAWuB,MAXlB;AAAA;AAAA;AAAA;;AAYDC,gBAAAA,OAZC,GAYS;AACV9D,kBAAAA,QAAQ,EAAE+C,aADA;AACc;AACxBC,kBAAAA,MAAM,EAAEA,MAFE;AAGVJ,kBAAAA,MAAM,EAAEA,MAHE;AAIVmB,kBAAAA,IAAI,EAAE5B,IAAI,CAACG,KAAL,CAAWsB,CAAX,CAJI;AAKVI,kBAAAA,OAAO,EAAE,IALC;AAMVC,kBAAAA,aAAa,EAAEZ,QANL;AAOVa,kBAAAA,MAAM,EAAE,CAAC,QAAD,EAAW,mBAAX,EAAgC,MAAhC,EAAwC,QAAxC,EAAkD,eAAlD,EAAmE,UAAnE;AAPE,iBAZT;AAAA;AAAA,uBAsBCZ,OAAO,CAACa,YAAR,CAAqBL,OAArB,EAA8B,UAACM,OAAD,EAAUxD,MAAV,EAAqB;AAErD,yBAAO,IAAIX,OAAJ,CAAY,UAACE,MAAD,EAASD,OAAT,EAAqB;AACpC,wBAAIU,MAAM,KAAKN,MAAM,CAACC,IAAP,CAAYgD,MAAZ,CAAmBc,mBAAnB,CAAuC3C,EAAtD,EAA0D;AACtD,0BAAIkC,CAAJ;;AACA,2BAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGQ,OAAO,CAACP,MAAxB,EAAgCD,CAAC,EAAjC;AACID,wBAAAA,MAAM,CAAC/D,IAAP,CAAYwE,OAAO,CAACR,CAAD,CAAnB;AADJ;;AAGA1D,sBAAAA,OAAO,CAACyD,MAAD,CAAP;AACAjB,sBAAAA,YAAY,CAACiB,MAAD,CAAZ;AACH,qBAPD,MAOO;AACHxD,sBAAAA,MAAM;AACT;AACJ,mBAXM,CAAP;AAaH,iBAfK,CAtBD;;AAAA;AAW0ByD,gBAAAA,CAAC,EAX3B;AAAA;AAAA;;AAAA;AAuCP;AAEFhC,gBAAAA,OAAO,CAACwB,GAAR,CAAYO,MAAZ;;AAzCS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,OAJR;AA+CHW,IAAAA,UAAU,EAAE,2BAA0B;AAAA,UAAvBC,OAAuB,SAAvBA,OAAuB;AAAA,UAAdC,OAAc,SAAdA,OAAc;;AAClC,UAAIC,SAAS,CAACC,WAAd,EAA2B;AACvBD,QAAAA,SAAS,CAACC,WAAV,CAAsBC,kBAAtB,CACI,UAAA1F,QAAQ,EAAI;AACRsF,UAAAA,OAAO,GAAGtF,QAAQ,CAAC2F,MAAT,CAAgBC,QAA1B;AACAL,UAAAA,OAAO,GAAGvF,QAAQ,CAAC2F,MAAT,CAAgBE,SAA1B;AACH,SAJL;AAMH;AAEJ;AAzDE,GAAP;AA2DH,CAhEW,CA3Fc,CAAP,CA4JrB,UAACvF,KAAD,EAAW;AAETqC,EAAAA,OAAO,CAACwB,GAAR,CAAY3E,aAAZ;AACA,MAAIc,KAAK,CAACgE,MAAN,IAAgB,IAApB,EAEA,IAAG9E,aAAa,CAAC,CAAD,CAAb,KAAoB4D,SAAvB,EACA,IAAI0C,MAAM,GAAG,IAAIzE,MAAM,CAACC,IAAP,CAAYa,MAAhB,CAAuB,OAAvB,EAAgC,CAAC,QAAjC,CAAb,CANS,CAMgD;;AACzDQ,EAAAA,OAAO,CAACwB,GAAR,CAAY,YAAY2B,MAAxB;;AACA,MAAIxF,KAAK,CAACwD,aAAN,KAAwBV,SAA5B,EAAuC;AAEnC0C,IAAAA,MAAM,GAAGxF,KAAK,CAACwD,aAAf;AACH;;AAELnB,EAAAA,OAAO,CAACwB,GAAR,CAAY1E,MAAZ;AACI,MAAIsG,MAAM,GAAG,EAAb,CAdS,CAcQ;;AACjB,MAAIzF,KAAK,CAACgE,MAAV,EAAkB;AAEd;AACAhE,IAAAA,KAAK,CAACgE,MAAN,CAAanB,GAAb,CAAiB,UAAC6C,KAAD,EAAQC,CAAR,EAAc;AAC3BtD,MAAAA,OAAO,CAACwB,GAAR,CAAY7D,KAAK,CAACqD,MAAlB;AACA,UAAIgB,CAAC,GAAEtD,MAAM,CAACC,IAAP,CAAYM,QAAZ,CAAqBsE,SAArB,CAA+BC,sBAA/B,CAAsDL,MAAtD,EAA8D,IAAIzE,MAAM,CAACC,IAAP,CAAYa,MAAhB,CAAuB6D,KAAK,CAACpE,QAAN,CAAeb,QAAf,CAAwBe,GAAxB,EAAvB,EAAsDkE,KAAK,CAACpE,QAAN,CAAeb,QAAf,CAAwBgB,GAAxB,EAAtD,CAA9D,CAAP;AACAY,MAAAA,OAAO,CAACwB,GAAR,CAAYQ,CAAZ;;AACA,UAAItD,MAAM,CAACC,IAAP,CAAYM,QAAZ,CAAqBsE,SAArB,CAA+BC,sBAA/B,CAAsDL,MAAtD,EAA8D,IAAIzE,MAAM,CAACC,IAAP,CAAYa,MAAhB,CAAuB6D,KAAK,CAACpE,QAAN,CAAeb,QAAf,CAAwBe,GAAxB,EAAvB,EAAsDkE,KAAK,CAACpE,QAAN,CAAeb,QAAf,CAAwBgB,GAAxB,EAAtD,CAA9D,IAAsJzB,KAAK,CAACqD,MAAhK,EAAwK;AACpKhB,QAAAA,OAAO,CAACwB,GAAR,CAAY,gBAAZ;AACA4B,QAAAA,MAAM,CAACpF,IAAP,CAAYqF,KAAZ;AACH;;AACD,UAAIA,KAAK,CAACI,WAAN,IAAqB9F,KAAK,CAACsD,KAA/B,EAAsC;AAClCjB,QAAAA,OAAO,CAACwB,GAAR,CAAY,aAAZ;AACA4B,QAAAA,MAAM,CAACpF,IAAP,CAAYqF,KAAZ;AACH;;AAED,UAAIA,KAAK,CAACK,MAAN,IAAgB/F,KAAK,CAACgG,OAA1B,EAAmC;AAC/B3D,QAAAA,OAAO,CAACwB,GAAR,CAAY,eAAZ;AACA4B,QAAAA,MAAM,CAACpF,IAAP,CAAYqF,KAAZ;AACH;AAED;;;AAGA;AACA;AACA;AAEA;;AAGH,KA5BD;AA8BH;;AAGDrD,EAAAA,OAAO,CAACwB,GAAR,CAAY4B,MAAZ;AACA,SAEI,oBAAC,SAAD;AACI,IAAA,aAAa,EAAEzF,KAAK,CAACkD,WADzB;AAEI,IAAA,GAAG,EAAElD,KAAK,CAACgD,YAFf;AAII,IAAA,OAAO,EAAEhD,KAAK,CAACkD,WAJnB;AAKI,IAAA,WAAW,EAAE,EALjB;AAMI,IAAA,aAAa,EAAE;AAAE1B,MAAAA,GAAG,EAAE,UAAP;AAAmBC,MAAAA,GAAG,EAAE,CAAC;AAAzB,KANnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAQKgE,MAAM,IAAIA,MAAM,CAAC5C,GAAP,CAAW,UAAC6C,KAAD,EAAQC,CAAR;AAAA,WAElB,oBAAC,MAAD;AAAQ,MAAA,GAAG,EAAEA,CAAb;AAAgB,MAAA,QAAQ,EAAE;AAAEnE,QAAAA,GAAG,EAAEkE,KAAK,CAACpE,QAAN,CAAeb,QAAf,CAAwBe,GAAxB,EAAP;AAAsCC,QAAAA,GAAG,EAAEiE,KAAK,CAACpE,QAAN,CAAeb,QAAf,CAAwBgB,GAAxB;AAA3C,OAA1B;AACI,MAAA,OAAO,EAAE,mBAAM;AAAEzB,QAAAA,KAAK,CAAC0C,YAAN,CAAmBiD,CAAnB;AAAuB,OAD5C;AAC8C,MAAA,IAAI,EAAE;AAAEM,QAAAA,GAAG,EAAEP,KAAK,CAACQ,IAAb;AAAmBC,QAAAA,UAAU,EAAE,IAAIpF,MAAM,CAACC,IAAP,CAAYoF,IAAhB,CAAqB,EAArB,EAAyB,EAAzB;AAA/B,OADpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAEKpG,KAAK,CAACuC,MAAN,IAAgBvC,KAAK,CAACwC,WAAN,KAAsBmD,CAAtC,IACG,oBAAC,UAAD;AAAY,MAAA,YAAY,EAAE3F,KAAK,CAAC0C,YAAhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAMgD,KAAK,CAACW,IAAZ,CADJ,CAHR,CAFkB;AAAA,GAAX,CARf,EAsBKrG,KAAK,CAACoC,UAAN,IAAoB,oBAAC,kBAAD;AAAoB,IAAA,UAAU,EAAEpC,KAAK,CAACoC,UAAtC;AAAkD,IAAA,eAAe,EAAEpC,KAAK,CAACO,OAAzE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAtBzB,CAFJ;AA8BH,CA9OsB,CAAvB;;IAgPqB+F,O;;;;;;;;;;;;;6BAGR;AAEL,UAAIlD,cAAc,GAAG,KAAKpD,KAAL,CAAWuG,MAAhC;AACA,UAAIlD,MAAM,GAAG,KAAKrD,KAAL,CAAWqD,MAAxB;AACA,UAAIC,KAAK,GAAG,KAAKtD,KAAL,CAAWsD,KAAvB;AACA,UAAI0C,OAAO,GAAG,KAAKhG,KAAL,CAAWwG,OAAzB;AACA,UAAIC,KAAK,GAAG,EAAZ;AACA,UAAIxG,SAAS,GAAC,KAAKD,KAAL,CAAWC,SAAzB;;AAGA,UAAImD,cAAc,CAACkB,MAAf,KAA0B,CAA1B,IAA+BjB,MAAM,KAAK,CAA1C,IAA+CC,KAAK,KAAK,CAA7D,EAAgE;AAC5DjB,QAAAA,OAAO,CAACwB,GAAR,CAAYT,cAAc,GAAG,GAAjB,GAAuBC,MAAvB,GAAgC,GAAhC,GAAsCC,KAAtC,GAA8C,GAA9C,GAAoD0C,OAAhE;AAGA5C,QAAAA,cAAc,CAACP,GAAf,CAAmB,UAAA6D,MAAM,EAAI;AACzBD,UAAAA,KAAK,CAACpG,IAAN,CAAWqG,MAAM,CAACC,KAAlB;AACH,SAFD;AAIA,eACI,oBAAC,cAAD;AAAgB,UAAA,cAAc,EAAEF,KAAhC;AACI,UAAA,KAAK,EAAEnD,KAAK,GAAG,CADnB;AAEI,UAAA,MAAM,EAAE0C,OAFZ;AAGI,UAAA,MAAM,EAAE3C,MAAM,GAAG,IAHrB,CAG2B;AAH3B;AAII,UAAA,SAAS,EAAEpD,SAJf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AAQH;;AAED,aAAS;AACL,4BAAC,cAAD;AAAgB,UAAA,cAAc,EAAC,EAA/B;AACI,UAAA,KAAK,EAAC,KADV;AAEI,UAAA,MAAM,EAAC,KAFX;AAGI,UAAA,MAAM,EAAC,GAHX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADJ;AASH;;;;EAxCgC/B,KAAK,CAAC0I,S;;SAAtBN,O","sourcesContent":["/*global google*/\nimport React from \"react\"\nimport { compose, withProps, withHandlers, withState, withStateHandlers, lifecycle } from \"recompose\"\nimport { withScriptjs, withGoogleMap, GoogleMap, Marker, InfoWindow, DirectionsRenderer } from \"react-google-maps\"\nimport { connect } from 'react-redux'\nimport meal from './meal.png'\nimport bakery from './bakery.png'\n\nvar route_markers = [];\nvar center;\nconst MyMapComponent = compose(\n\n    withProps(\n        {\n            googleMapURL: \"https://maps.googleapis.com/maps/api/js?key=AIzaSyD8kEdQYnlfJaGYD70GNqtxzf7oet_3wwY&libraries=places,geometry\",\n            loadingElement: <div style={{ height: '100vh' }} />,\n            containerElement: <div style={{ height: '100vh' }} />,\n            mapElement: <div style={{\n                position: \"relative\",\n                width: \"50%\",\n                height: 480,\n                //WebkitFilter: \"drop-shadow(0px 0px 30px )\",\n                marginLeft: 482,\n                marginTop: -510,            }}\n            />,\n        }),\n    withScriptjs,\n    withGoogleMap,\n    lifecycle({\n        componentWillMount(){\n            this.getGeoLocation()\n        },\n        async getGeoLocation(){ //this method gets the geolocation coordinates by calling getLocationCoordinates while passing location names as input from user\n            if(this.props.locations ){\n              const locations = this.props.locations; //passing array with start and end destination names \n               route_markers = [];//used to store the geolocation \n            const from = await this.getLocationCoordinates(locations.from); //returns coordinate of start dest\n            const to = await this.getLocationCoordinates(locations.to); //returns coordinates of end dest\n            route_markers.push(from); //add to the array\n            route_markers.push(to);//add to the array \n            this.setState({markers:route_markers})\n            this.componentDidMount(route_markers)\n            }\n          },\n    \n          getLocationCoordinates(location){//computes the geocoordinates of given locations using googles Geocoder \n            return new Promise((resolve, reject)=>{\n              const geocoder = new window.google.maps.Geocoder();\n              geocoder.geocode({address:location}, (result, status)=>{\n                if(status=='OK'){\n                  const geometry = result[0].geometry.location\n                  const coordinates = {\n                    lat: geometry.lat(),\n                    lng:geometry.lng()\n                  }\n                  resolve(coordinates);\n                 \n                }\n                else{\n                  reject('ERROR')\n                }\n              })\n              \n            });\n          \n          },\n        componentDidMount(route_markers) { //this method draws the route between start and end destination\n            if(route_markers){\n            const DirectionsService = new google.maps.DirectionsService();\n            DirectionsService.route({\n                origin: new google.maps.LatLng(route_markers[0].lat, route_markers[0].lng),\n                destination: new google.maps.LatLng(route_markers[1].lat, route_markers[1].lng),\n                travelMode: google.maps.TravelMode.DRIVING,\n            }, (result, status) => {\n                if (status === google.maps.DirectionsStatus.OK) {\n//console.log(result)\n                    this.setState({\n                        directions: { ...result },\n                        markers: true\n                    })\n                } else {\n                    console.error(`error fetching directions ${result}`);\n                }\n            });\n        }\n    }\n    }),\n    withState('places', 'updatePlaces', '', 'searchCriteria', 'radius', 'currLat', 'currLng'),\n    withStateHandlers(() => ({\n        isOpen: false,\n        markerIndex: 0,\n        currentLatLng: {\n            lat: 47.6769683, lng: -90.6769683\n        }\n    }), {\n            onToggleOpen: ({ isOpen }) => (index) => ({ //used to handle info window on markers \n                isOpen: !isOpen,\n                markerIndex: index\n            })\n        },\n    ),\n    withHandlers(() => {\n        const refs = {\n            map: undefined,\n            array: []\n        }\n        return {\n            onMapMounted: () => ref => {\n                refs.map = ref\n            },\n            fetchPlaces: async ({ updatePlaces, searchCriteria, radius, price, review, defaultCenter }) => { //fetches new places to dispaly on map by making a request to googles PlaceService api\n                const bounds = refs.map.getBounds();\n                center=refs.map.getCenter();\n                refs.map.panToBounds(bounds)\n                console.log(bounds)\n                refs.array = searchCriteria\n                var maxPrice = price;\n                const service = new google.maps.places.PlacesService(refs.map.context.__SECRET_MAP_DO_NOT_USE_OR_YOU_WILL_BE_FIRED);\n                var x;\n                var output = [];\n\n                for (x = 0; x < refs.array.length; x++) {\n                    var request = {\n                        location: defaultCenter,//location:(new google.maps.LatLng(47.6769683,-122.0284808)),or {lat:47.6769683,lng:-122.0284808}\n                        bounds: bounds,\n                        radius: radius,\n                        type: refs.array[x],\n                        openNow: true,\n                        maxPriceLevel: maxPrice,\n                        fields: ['photos', 'formatted_address', 'name', 'rating', 'opening_hours', 'geometry']\n                    };\n\n                    await service.nearbySearch(request, (results, status) => {\n\n                        return new Promise((reject, resolve) => {\n                            if (status === google.maps.places.PlacesServiceStatus.OK) {\n                                var x;\n                                for (x = 0; x < results.length; x++)\n                                    output.push(results[x]);\n\n                                resolve(output);\n                                updatePlaces(output);\n                            } else {\n                                reject();\n                            }\n                        })\n\n                    })\n\n                } //end of forloop \n\n                console.log(output);\n            },\n            currentLoc: ({ currLat, currLng }) => {\n                if (navigator.geolocation) {\n                    navigator.geolocation.getCurrentPosition(\n                        position => {\n                            currLat = position.coords.latitude\n                            currLng = position.coords.longitude\n                        })\n\n                }\n\n            }\n        }\n    }),\n)((props) => {\n\n    console.log(route_markers)\n    if (props.places != null)\n\n    if(route_markers[0]!== undefined)\n    var target = new google.maps.LatLng(47.6062, -122.3321); //this needs to update with the bound and not be fixed like this\n    console.log(\"TARGET:\" + target)\n    if (props.defaultCenter !== undefined) {\n        \n        target = props.defaultCenter\n    }\n    \nconsole.log(center)\n    var option = []; //new array to store results based on search criteria\n    if (props.places) {\n\n        //traverse through the place array, if there is a match between radius , price level. Enables makers to show without other information \n        props.places.map((place, i) => {\n            console.log(props.radius)\n            var x= google.maps.geometry.spherical.computeDistanceBetween(target, new google.maps.LatLng(place.geometry.location.lat(), place.geometry.location.lng()));\n            console.log(x)\n            if (google.maps.geometry.spherical.computeDistanceBetween(target, new google.maps.LatLng(place.geometry.location.lat(), place.geometry.location.lng())) < props.radius) {\n                console.log(\"DISTANCE MATCH\");\n                option.push(place);\n            }\n            if (place.price_level <= props.price) {\n                console.log(\"PRICE MATCH\");\n                option.push(place);\n            }\n\n            if (place.rating <= props.ratings) {\n                console.log(\"RATINGS MATCH\");\n                option.push(place);\n            }\n\n            /*\n            cant have any markers appear if user enters only type, we need more information along with type. \n            */\n            // if(place.types.length !== 0 && place.types.includes(props.searchCriteria)){ \n            //     console.log(\"here \"+props.searchCriteria)\n            //     option.push(place)\n\n            // }\n\n\n        }\n        )\n    }\n\n\n    console.log(option);\n    return (\n\n        <GoogleMap\n            onTilesLoaded={props.fetchPlaces}\n            ref={props.onMapMounted}\n         \n            onClick={props.fetchPlaces}\n            defaultZoom={13}\n            defaultCenter={{ lat: 47.6769683, lng: -122.0284808 }}\n        >\n            {option && option.map((place, i) =>\n\n                <Marker key={i} position={{ lat: place.geometry.location.lat(), lng: place.geometry.location.lng() }}\n                    onClick={() => { props.onToggleOpen(i) }} icon={{ url: place.icon, scaledSize: new google.maps.Size(25, 25) }} >\n                    {props.isOpen && props.markerIndex === i &&\n                        <InfoWindow onCloseClick={props.onToggleOpen}>\n                            <div>{place.name}</div>\n                        </InfoWindow>\n                    }\n                </Marker>\n\n            )}\n            {/*for creating path with the updated coordinates*/}\n\n            {props.directions && <DirectionsRenderer directions={props.directions} suppressMarkers={props.markers} />}\n\n        </GoogleMap>\n\n    )\n\n})\n\nexport default class MealMap extends React.Component {\n\n\n    render() {\n\n        var searchCriteria = this.props.search;\n        var radius = this.props.radius;\n        var price = this.props.price;\n        var ratings = this.props.reviews;\n        var types = [];\n        var locations=this.props.locations;\n\n\n        if (searchCriteria.length !== 0 || radius !== 0 || price !== 0) {\n            console.log(searchCriteria + \" \" + radius + \" \" + price + \" \" + ratings)\n\n\n            searchCriteria.map(select => {\n                types.push(select.label)\n            })\n\n            return (\n                <MyMapComponent searchCriteria={types}\n                    price={price * 1}\n                    review={ratings}\n                    radius={radius * 1609} //converting into meters\n                    locations={locations}\n                />\n            )\n        }\n\n        return ( //to prevent from crashing\n            <MyMapComponent searchCriteria=''\n                price=\"any\"\n                review=\"any\"\n                radius='0'\n            />\n        )\n\n\n    }\n\n}"]},"metadata":{},"sourceType":"module"}